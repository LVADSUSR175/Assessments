# -*- coding: utf-8 -*-
"""LVADSUSR175_Datla_Prahalladh_IA_2_Q1_CLASSIFICATION.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qYO-Bc2_HqveQoM4sE1oyyyyENrY1k0s
"""

import pandas as pd
df = pd.read_csv("/content/winequality-red.csv")
df

df.shape

df.head(5)

df.info()

df["quality"].value_counts()

df.isnull().sum() #found some null values

df["fixed acidity"].value_counts()
df["volatile acidity"].value_counts()
df["citric acid"].value_counts()
df["residual sugar"].value_counts()
df["chlorides"].value_counts()

df.duplicated().sum() # found 217 duplicates

df[df.duplicated()] # But not removing the duplicates because the values can always be same

# EDA
#Univariate Analysis
import matplotlib.pyplot as plt
import seaborn as sns

# Plot histograms for numerical columns
for column in df.select_dtypes(include=['float64', 'int64']).columns:
    plt.figure(figsize=(10, 5))
    sns.histplot(df[column])
    plt.title(f'Histogram of {column}')
    plt.xlabel(column)
    plt.ylabel('Frequency')
    plt.show()

# Co-orelation
numerical_columns = df.select_dtypes(include=['float64', 'int64']).columns
correlation_matrix = df[numerical_columns].corr()
print("Correlation matrix:\n", correlation_matrix)


# Plot the correlation matrix as a heatmap
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, fmt=".2f", cmap='coolwarm')
plt.title('Heatmap of Correlation Matrix')
plt.show()

# Generate scatter plots for pairs of numerical variables
numerical_columns = df.select_dtypes(include=['float64', 'int64']).columns
for i in range(len(numerical_columns)):
    for j in range(i + 1, len(numerical_columns)):
        plt.figure(figsize=(10, 6))
        sns.scatterplot(data=df, x=numerical_columns[i], y=numerical_columns[j])
        plt.title(f'Scatter Plot between {numerical_columns[i]} and {numerical_columns[j]}')
        plt.show()

df.info()

# Outliers
# Generate scatter plots for pairs of numerical variables
numerical_columns = df.select_dtypes(include=['float64', 'int64']).columns
for i in range(len(numerical_columns)):
    for j in range(i + 1, len(numerical_columns)):
        plt.figure(figsize=(10, 6))
        sns.scatterplot(data=df, x=numerical_columns[i], y=numerical_columns[j])
        plt.title(f'Scatter Plot between {numerical_columns[i]} and {numerical_columns[j]}')
        plt.show()

df.isnull().sum()

#Removing Null Values
df["fixed acidity"].fillna(df["fixed acidity"].mean(),inplace = True)
df["volatile acidity"].fillna(df["volatile acidity"].mean(),inplace = True)
df["citric acid"].fillna(df["citric acid"].mean(),inplace = True)
df["residual sugar"].fillna(df["residual sugar"].mean(),inplace = True)
df["chlorides"].fillna(df["chlorides"].mean(),inplace = True)
df["free sulfur dioxide"].fillna(df["free sulfur dioxide"].mean(),inplace = True)
df["sulphates"].fillna(df["sulphates"].mean(),inplace = True)

#As all the columns are in numerical only so need for encoding

X = df.drop(columns =["quality"])
Y = df["quality"]

from sklearn.model_selection import train_test_split
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.3, random_state=40)

#Normalization
from sklearn.preprocessing import MinMaxScaler,StandardScaler
scaler = MinMaxScaler()
X_train=pd.DataFrame(scaler.fit_transform(X_train[list(X.columns)]),
                                    columns=X.columns)
X_test=pd.DataFrame(scaler.transform(X_test[list(X.columns)]),
                                    columns=X.columns)

#Model  and evaluation
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score
model =  KNeighborsClassifier(n_neighbors=2)
model.fit(X,Y)

# Predictions
Y_pred = model.predict(X)
accuracy = accuracy_score(Y_pred,Y)
print("Model Prediction Accuracy: %.2f%%" % (accuracy * 100.0))

model =  KNeighborsClassifier(n_neighbors=3)
model.fit(X,Y)

# Predictions
Y_pred = model.predict(X)
accuracy = accuracy_score(Y_pred,Y)
print("Model Prediction Accuracy: %.2f%%" % (accuracy * 100.0))

model =  KNeighborsClassifier(n_neighbors=4)
model.fit(X,Y)

# Predictions
Y_pred = model.predict(X)
accuracy = accuracy_score(Y_pred,Y)
print("Model Prediction Accuracy: %.2f%%" % (accuracy * 100.0))